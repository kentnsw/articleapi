# Article API

This project contains source code and supporting files for dockerized GraphQL API for creating and query articles. The GQL endpoint is `http://localhost:8080/query`. The playground is available at `http://localhost:8080/`. Please see example queries below.

## Prerequisites

- Docker engine and compose
- ports: `8080` for the http server, `27017` for the MongoDB (for easy access to the DB manually)

## Start the application

Clone the repository into your local environment.
To start the application, please run the following commands. It will need a couple of minutes to download 3rd-party images and build the images. If you don't want to run the containers in detached mode, remove the `-d` option.

```bash
docker compose up -d
```

To shut down the application, please run

```bash
docker compose down
```

## Source code structure and some thoughts

Key files and their responsibilities are as follows.

```
articleapi
  |- graph
  |    |- model
  |    |    |- models_gen.go    // This is the models auto generated by gqlgen
  |    |    |- models_helper.go // a few helper funcs
  |    |    |- scalars.go       // custom scalars
  |    |- schema.graphqls       // the gql schema (gqlgen uses it to generate the models above)
  |    |- schema.resolvers.go   // the implementation, it wires up data access layer to obtain data
  |- storage/mongo
  |            |- article.go    // article CRUD logic
  |            |- mongo.go      // maintain the DB connections
  |- main.go                    // init DB connection and start up the http server
```

### Why gqlgen, mongo, docker and others

Choosing gqlgen is because I believe APIs will change and grow all the time. It has to be a lightweight approach to refactor and add APIs. The schema first approach looks very promising.

- modify the human-friendly `schema` to define APIs
- keep a `gql model` layer separated from the persistent `data model` to provide some level of flexibility
- use `resolvers` to wire up the data layer(s)

Mongo is a document database that is a great fit for keeping data like articles with tagging. It is simpler than using a RMDB with a multiple tables e.g. `artitles` <--> `artitle-tag-relations` <--> `tags`.

Using docker here is for easier setup and clean up. It's a good start point for running an application in a docker/Kubernetes cluster as well.

Another thought is implementing this with AWS AppSync + DynamoDB must be fun.

## Examples

Here are a few examples for you to test it a bit at the playground.

### Create an artile

```json
mutation{
  createArticle(article:{
    title: "this is a title",
    body: "article body goes here",
    date: "2021-04-22",
    tags: ["health", "beauty"]
  }) {
    id
    title
    tags
  }
}
```

### Get an artile by ID

```json
query{
  article(id:"article ID goes here, e.g. copy the id value from the above response"){
    id
    title
    body
    tags
    date
  }
}
```

### Load multiple articles

```json
mutation{
  createArticles(articles:[
    {
      title: "article title 1",
      body: "article body 1",
      date: "2021-05-23",
      tags: ["health"]
    },
    {
      title: "article title 2",
      body: "article body 2",
      date: "2021-05-23",
      tags: ["health", "food"]
    },
  ])
}
```

### Search articles by a tag

```json
query{
  articlesByTag(filter:{
    tag: "health",
    date: "2021-05-23",
    limit: 10
  })
  {
    tag
    count
    articles
    related_tags
  }
}
```
